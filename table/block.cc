// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.
//
// 解析由 block_builder.cc 生成的 blocks

#include "table/block.h"

#include <vector>
#include <algorithm>
#include "leveldb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace leveldb {

// 每个 Block 末尾 32 位存着 restart 的个数。
// 该方法解析并返回之。
inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) { //　当数据存储在堆上的时候 owned_ 才为 true
  if (size_ < sizeof(uint32_t)) { // block 最后 4 字节用于存储 restart 个数，所以最小也为 4 字节长度
    size_ = 0;  // Error marker
  } else {
    // 该 Block 最多可以分配的 restart 的个数，其中每个 restart 为 4 字节偏移量，
    // 在构建 block 的时候会每隔一段设置一个 restart point，位于 restart point 的数据项的 key 不会进行前缀压缩，此项之后
    // 的数据项会相对于前一个数据项进行前缀压缩直至下一个 restart  point。
    // block 最后 4 字节用于存储 restart 个数，所以计算时不能算在内。
    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0; // 如果实际的 restart 总数超过了上面计算的最大值，那该 Block 空间太小了，肯定有问题
    } else {
      // 最后一个 uint_32 存的是 restart 个数，不能用于存放 restart；
      // 全部 restart 占用字节数为 NumRestarts() * sizeof(uint32_t)；
      // 所以 restart array 的起始 offset 为下面的值。
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}

Block::~Block() {
  if (owned_) { // 为 true 表示数分配在堆上（见构造方法），析构时候需要释放相应内存。
    delete[] data_;
  }
}

// Helper routine: decode the next block entry starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not dereference past "limit".
//
// If any errors are detected, returns nullptr.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).
//
// 辅助函数：从 p 指向内存解码下一个 block entry，同时将共享的 key 字节数、非共享的 key 字节数
// 以及 value 的长度存储到 *shared、*non_shared 以及 *value_length。解码时不会越过 limit。
//
// 如果解码过程出错，返回 nullptr。其他情况下，返回一个指向这三个值之后的内存的地址，即非共享 key 部分的起始地址。
static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared,
                                      uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p < 3) return nullptr;
  *shared = reinterpret_cast<const unsigned char*>(p)[0];
  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
  *value_length = reinterpret_cast<const unsigned char*>(p)[2];
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    // 表示三个值的所各自存储的字节的最高位都不为 1，
    // 这表示没有后续字节来存储他们长度了（varint32 编码就这样的，最高位是标识位，1 表示还有后续字节，否则没了）
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
  }

  // p 此时指向非共享的 key 的起始位置（如果全部为共享 key，则指向 value 起始地址）
  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return nullptr;
  }
  return p;
}

class Block::Iter : public Iterator {
 private:
  // 迭代时使用的比较器
  const Comparator* const comparator_;
  // 指向 block 的指针
  const char* const data_;      // underlying block contents
  // block 的 restart 数组（保存着每个 restart 在 block 里的偏移量）在 block 里的起始偏移量
  uint32_t const restarts_;     // Offset of restart array (list of fixed32)
  // restart 数组元素个数
  uint32_t const num_restarts_; // Number of uint32_t entries in restart array

  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  //
  // current_ 表示当前数据项在 data_ 里的偏移量，如果迭代器无效则该值大于等于 restarts_ 即 restart array 在 block 的起始偏移量
  // (restart array 位于 block 后部，数据项在 block 前半部分）
  uint32_t current_;
  // current_ 指向的数据项所处 restart 的索引值
  uint32_t restart_index_;  // Index of restart block in which current_ falls
  std::string key_; // current_ 所指数据项的 key
  Slice value_; // current_ 所指数据项的 value
  Status status_;

  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }

  // Return the offset in data_ just past the end of the current entry.
  //
  // 返回 current_ 所指数据项的下一个数据项的偏移量。
  // 根据 Block 布局我们可以知道，value 位于每个数据项最后，所以 value 之后第一个字节即为下一个数据项起始位置。
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  // 返回索引值为 index 的 restart 在 block 中的偏移量
  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  // 将迭代器移动到索引值为 index 的 restart 对应的偏移量位置
  void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey(); current_ 会被 ParseNextKey 来设置

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    // 将 value 数据起始地址设置为 offset 对应的 restart 起始位置，
    // value_ 这么设置是为了方便 ParseNextKey
    value_ = Slice(data_ + offset, 0);
  }

 public:
  Iter(const Comparator* comparator,
       const char* data,
       uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }

  virtual bool Valid() const { return current_ < restarts_; }
  virtual Status status() const { return status_; }
  virtual Slice key() const {
    assert(Valid());
    return key_;
  }
  virtual Slice value() const {
    assert(Valid());
    return value_;
  }

  // 将 current 指向下一个数据项（key、value、
  virtual void Next() {
    assert(Valid());
    ParseNextKey();
  }

  // 将 current 指向当前数据项前一个数据项。
  // 如果 current 指向的已经是 block 第 0 个数据项，则无须移动了；
  virtual void Prev() {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    // 当 current_ 恰好与所处 restart 段起始地址一样时候，等于才会成立，一般都是 current 大于所处 restart 段起始地址。
    // 下面循环干一件事：
    // - 如果 current 大于所处 restart 段起始地址，不进行循环，到下面去直接定位 current 前一个数据项即可
    // - 如果 current 等于所处 restart 段起始地址，
    //    - 如果当前 restart 不是 block 的首个 restart，则 current 前一个数据项肯定位于前一个 restart 最后一个位置
    //    - 如果当前 restart 是 block 的首个 restart，则 current 就是 block 首个数据项，所以没有所谓前一个数据项了
    // - 没有其它情况。
    while (GetRestartPoint(restart_index_) >= original) { // 循环能够执行的唯一条件就是相等
      if (restart_index_ == 0) { // 如果 restart_index_ 等于 0，说明 current 位于 block 首个 restart 的首个数据项处，不存在前一个数据项
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }

    // 注意，此方法只调整了 current 对应的 value，此时两者不再保持一致；
    // current 与 key 仍然保持一致性。
    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }

  // 寻找 block 中第一个 key 大于等于 target 的数据项。
  // 先通过二分法在 restart 段级定位查找目标段（最后一个包含依然小于 target 的 key 的段），
  // 然后在目标段进行线性查找找到第一个 key 大约等于 target 的数据项。
  // 如果存在则 current 指向该目标数据项；否则 current 指向一个非法数据项。调用者需要检查返回结果以确认是否找到了。
  virtual void Seek(const Slice& target) {
    // Binary search in restart array to find the last restart point
    // with a key < target
    // 在 restart array 中进行二分查找，找到最后一个存在 key 小于 target 的 restart，注意是小于，这决定了后面二分查找时比较逻辑。
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset,
                                        data_ + restarts_,
                                        &shared, &non_shared, &value_length);
      // 注意，在 block 中，每个位于 restart 处的数据项的 key 肯定是没有做过前缀压缩的，所以 shared 肯定为 0.
      // 同时要注意，这是异常情况，不属于循环不变式的成立的条件。
      if (key_ptr == nullptr || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      // 因为 block 中 key 都是递增排列的，所以每个 restart 段位于 restart 首位置的那个 key 肯定是所在段最小的。
      // 如果最后存在这样的 restart，肯定是由 left 指向：
      // - 因为 left 右移的条件是远小于 target
      // - 因为 right 左移的条件是大于等于 target
      if (Compare(mid_key, target) < 0) {
        // Key at "mid" is smaller than "target".  Therefore all
        // blocks before "mid" are uninteresting.
        left = mid;
      } else {
        // Key at "mid" is >= "target".  Therefore all blocks at or
        // after "mid" are uninteresting.
        right = mid - 1;
      }
    }

    // 即使初始 left == right 也会走到这

    // Linear search (within restart block) for first key >= target
    SeekToRestartPoint(left);
    // 定位到 left 指向的 restart 段以后，挨个 key 进行比较，寻找第一个大于等于 target 的 key
    while (true) {
      if (!ParseNextKey()) {
        return;
      }
      if (Compare(key_, target) >= 0) {
        return;
      }
    }
  }

  // 将迭代器移动到 block 第一个数据项
  virtual void SeekToFirst() {
    SeekToRestartPoint(0);
    ParseNextKey();
  }

  // 将迭代器移动到 block 最后一个数据项
  virtual void SeekToLast() {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }

 private:
  // 如果出错，则将各个成员置为非法值
  void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption("bad entry in block");
    key_.clear();
    value_.clear();
  }

  // 将 current、key、value 指向下一个数据项的起始偏移量、key 部分、value 部分，、
  // 同时保持 restart_index 与 current 新位置所处 restart 段一致。
  bool ParseNextKey() {
    current_ = NextEntryOffset(); // current 指向接下来的数据项
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    // key 保存的还是前一个数据项的 key，而大小必然不小于接下来的数据项的 key 与其公共前缀部分大小
    if (p == nullptr || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared); // 保留公共前缀部分
      key_.append(p, non_shared); // 将当前数据项 key 的非公共部分追加进来，得到一个完整的 key
      value_ = Slice(p + non_shared, value_length); // 当前数据项的 value 部分。到此为止，current、key、value 都已指向同一个数据项。
      // 下面循环干的事情，就是要保持 restart_index 与 current 一致，即让 restart_index 指向 current 所处 restart 的在数组中的索引值。
      // 因为 current 已经指向新的数据项，所以它所处的 restart 段可能也递增了，那就破坏了与 restart_index 的一致性，所以需要调整。
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) { // restart_index_ 如果指向最后一个 restart，那么 current 此时肯定也在最后一个 restart 段。
        ++restart_index_;
      }
      return true;
    }
  }
};

// 根据用户定制的 comparator 返回该 block 的一个迭代器
Iterator* Block::NewIterator(const Comparator* cmp) {
  if (size_ < sizeof(uint32_t)) { // block 尾部 4 字节为 restart 个数，最少 4 字节
    return NewErrorIterator(Status::Corruption("bad block contents"));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(cmp, data_, restart_offset_, num_restarts);
  }
}

}  // namespace leveldb
